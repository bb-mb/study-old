## 섹션 2. 함수형으로 전환하기.md

- 함수형 프로그래밍에서 어떤 중복을 제거하거나 추상화를 할 때 함수를 사용한다.
- 추상화의 단위가 객체나 클래스가 아니라 함수를 사용함.

### map, filter, each
```javascript
const users = [
  { id: 1, name: 'ID', age: 36 },
  { id: 2, name: 'BJ', age: 32 },
  { id: 3, name: 'JM', age: 32 },
  { id: 4, name: 'PJ', age: 27 },
  { id: 5, name: 'HA', age: 25 },
  { id: 6, name: 'JE', age: 26 },
  { id: 7, name: 'JI', age: 31 },
  { id: 8, name: 'MP', age: 23 }
];

// 1. 명령형 코드
  // 1. 30세 이상인 users를 거른다.
var temp_users = [];
for (var i = 0; i < users.length; i++) {
  if (users[i].age >= 30) {
    temp_users.push(users[i]);
  }
}
console.log(temp_users);

  // 2. users의 names를 수집한다.
var names = [];
for (var i = 0; i < temp_users.length; i++) {
  names.push(temp_users[i].name);
}
console.log(names);

  // 3. 30세 미만인 users를 거른다.
var temp_users = [];
for (var i = 0; i < users.length; i++) {
  if (users[i].age < 30) {
    temp_users.push(users[i]);
  }
}
console.log(temp_users);

  // 4. users의 ages를 수집한다.
var ages = [];
for (var i = 0; i < temp_users.length; i++) {
  ages.push(temp_users[i].age);
}
console.log(ages);
```
- 명령형 코드에서는 중복되는 코드가 많다.
- 1번과 3번 코드에서는 if문의 조건만 다르고, 2번과 4번의 코드에서는 push에 들어갈 user의 속성만 바뀐다.
- filter와 map을 만들어서 중복되는 코드를 제거할 수 있다.

### filter
``` javascript
function _filter(list, predi){
    const new_list = []
    for(let i = 0; i < list.length; i++){
        if(predi(users[i])) new_list.push(users[i])
    }
    return new_list
}
// 1. 30세 이상인 users를 거른다.
console.log(_filter(users, (user) => user.age >= 30))
// 3. 30세 미만인 users를 거른다.
console.log(_filter(users, (user) => user.age <> 30))
```
- 다음과 같이 filter함수를 재사용함으로 코드 중복을 줄였다.
- 명령형 코드에서는 if문의 조건만 변경하는 식의 코드 중복제거가 쉽지 않지만 함수형 프로그래밍에서는 조건에 해당하는 함수를 인자로 받음으로서 쉽게 해결할 수 있다.
- 다형성이 높다. filter함수만 본다면 데이터 형태가 정해져있지 않기 때문에 다른 코드에도 사용할 수 있음.

### map
```javascript
function _map(list, mapper){
    const new_list = []
    for(let i = 0; i < list.length; i++){
        new_list.push(mapper(list[i]))
    }
    return new_list
}
// 2. users의 names를 수집한다.
console.log(_map(users, (user) => user.name))
// 4. users의 ages를 수집한다.
console.log(_map(users, (user) => user.age))
```
- 필터와 마찬가지로 다형성이 높아서 재사용성이 좋다.
- 필터와 맵을 합쳐서 30세 이상인 users의 이름을 출력하는식의 동작도 가능하다.
```javascript
console.log(_map(_filter(users, (user) => user.age >= 30), (user) => user.age))
```

### each
- _map과 _filter에도 중복되는 코드가 있다. for의 배열 순회 부분이다. 이를 each로 제거한다.

```javascript
function _each(list, iter) {
    for(let i = 0; i < list.length; i++){
        iter(list[i])
    }
    return list
}
//each를 사용하여 리팩토링한 filter와 map
function _filter(list, predi) {
    const new_list = []
    _each(list, (val) => {if(predi(val)) new_list.push(val)})
    return new_list
}
function _map(list, mapper) {
    const new_list = []
    _each(list, (val) => {new_list.push(mapper(val))})
    return new_list
}
```

### 다형성
- 맵이나 필터같은 함수는 이미 자바스크립트에 메서드로 있음.
하지만 이는 함수가 아닌 메서드이므로 순수함수가 아니다.
- 메서드는 객체 상태에 따라 결과가 달라지는 특징을 가지는 객체지향 프로그래밍의 특성을 가진다.
- 맵과 필터 메서드는 해당 클래스에 정의되어 있기 때문에 해당클래스의 인스턴스에만 사용할 수 있다. 따라서 메서드 맵과 필터는 array가 아니면 사용이 불가능하다.
- 자바스크립트에는 array가 아니지만 array처럼 사용하는 자료구조들이 많다.
대표적으로 jquery객체가 있음. array like 객체이다.

```javascript
console.log(document.querySelectorAll('*').map((node) => node.nodeName))
```
- 위의 객체는 array가 아닌 제이쿼리 객체이기 때문에 map메서드를 쓰면 에러가 남.
- 메서드는 해당 클래스에 준비되어 있지 않으면 사용할 수 없기 때문에 다형성을 지원하기 어렵다. 함수가 기준이 되는 함수형 프로그래밍은 함수를 먼저 만들고 함수에 맞는 데이터를 구성해서 함수에 적용하는 식으로 프로그래밍하게된다. 이는 굉장히 높은 다형성을 가진다.
- 함수가 먼저 나오는 프로그래밍은 데이터가 나오기 이전부터 함수가 있기 때문에 평가의 순서에 대한 제약이 덜하다.
- 함수형 순수함수에서 인자로 들어가는 함수는 모두 콜백함수인게 아니다. 콜백함수는 함수의 내부적인 로직을 끝마친 후에 실행하는 함수이고 위에서 만든 map 함수의 mapper와 같은 보조함수는 함수의 로직 내에서 실행되는 함수이다.